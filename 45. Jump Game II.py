from collections import deque
from typing import List


class Solution:
    def jump(self, nums: List[int]) -> int:
        return self.bfs(nums)
    
    # 这总和贪心没关系吧 求最小 绝对是dp
    # dp定义:
    # dp[i]代表从0到i的位置需要跳几次
    # 动态规划方程：
    # dp[i] = min(dp[j] + 1, dp[i]) if j + nums[j] >= i
    # 两次循环 不知道能不能优化 明天写吧
    # 虽然过了 但是有几个case耗时好长
    def dp(self, nums: List[int]) -> int:
        # 定义
        dp = [float('inf')] * len(nums)
        dp[0] = 0

        # 迭代计算
        for last in range(1, len(nums)):
            for pre in range(last):
                if pre + nums[pre] >= last:
                    dp[last] = min(dp[last], dp[pre] + 1)
        
        return dp[-1]

    # 简单优化下 第二次循环反着来看看 但是感觉差不多的样子
    # 确实快了蛮多 第二次循环往后走避免了不需要计算的部分 因为往后知道最多能到哪里 
    def dp_v2(self, nums: List[int]):
        # 定义
        dp = [float('inf')] * len(nums)
        dp[0] = 0

        # 迭代计算
        for pre in range(0, len(nums)):
            for last in range(pre + 1, min(pre + nums[pre] + 1, len(nums))):
                    dp[last] = min(dp[last], dp[pre] + 1)
        
        return dp[-1]
    
    # 绝对还能优化 一次循环试试
    # 看了下答案 就是找最远的那个可以到i的j去+1 最远的那个肯定是step最小的 省略掉中间那些无用的j的计算
    # 找j的过程用了双指针 很巧妙 避免了内部的第二次循环
    # 这次巨快 速度超越91% 内存超越61%
    # 感觉还能优化 因为迭代方程也只和最远的那个有关系 不需要数组来存储所有的
    def dp_v3(self, nums: List[int]):
        # 定义
        dp = [float('inf')] * len(nums)
        dp[0] = 0

        # 迭代计算
        point = 0
        for cur in range(1, len(nums)):
            # 指针找最远的
            while point + nums[point] < cur: 
                point += 1
            
            dp[cur] = dp[point] + 1

        return dp[-1]
    
    # 空间还能优化 明天写 其实就是贪心了 贪心是不是都可以从动态规划的思路去解释呢
    # 不再拘束在每个位置 而是按照第一次起跳 第二次起跳的最长来判断 太牛逼了 每次在可跳范围内选择使得下一步能够跳得最远的位置
    # 这里一个end无法处理 因为每次都更新到后面 i永远<end step永远是1 end是用来判断是否需要再一次跳跃的
    # 这个感觉有点难了
    def dp_v4(self, nums: List[int]):
        if len(nums) <= 1: return 0
        step = 1
        # 这是第一次的最大范围 超过就得跳
        end = nums[0]

        # 这是下一次跳跃能达到的最大范围
        max_r = 0

        # 这个指针直接省去一次更新最大范围的循环 牛啊
        for point in range(1, len(nums)):
            if point > end:
                step += 1
                # 这里跳完了上一次的范围 就变成下一次的最大范围了 开始处理下一次跳跃
                end = max_r
            
            max_r = max(max_r, point + nums[point])
            if end >= len(nums) - 1:
                break
        return step
    
    # bfs有点像非递归的递归 好久没写过了 明天写下 算一道题
    # 最早到最后一个的其实就是最短的 bfs原来是队列 好久没写 都忘了
    # 还有记录节点的 避免重复计算的浪费 真是博大精深啊
    # 比较难的地方在于如何剪枝
    def bfs(self, nums: List[int]):
        n = len(nums)
        if n == 1:
            return 0
        
        visited = [False] * n
        queue = deque([(0, 0)])
        while queue:
            pos, step = queue.popleft()
            if pos + nums[pos] >= n - 1:
                return step + 1
            
            if pos == n - 1:
                return step
            
            visited[pos + idx] = True
            for idx in range(1, nums[pos] + 1): # 遍历广度
                if pos + idx < n and not visited[pos + idx]:
                    queue.append([pos + idx, step + 1])

        return -1
    
    # 这样内存和时间都太长了 优化是把visited=true放到for里面
    # 在放到队列后马上置为True 避免后面每次都放进去 会死循环 queue也越来越长
    def bfs_v2(self, nums: List[int]):
        n = len(nums)
        if n == 1:
            return 0
        
        visited = [False] * n
        queue = deque([(0, 0)])
        while queue:
            pos, step = queue.popleft()
            if pos + nums[pos] >= n - 1:
                return step + 1
            
            if pos == n - 1:
                return step
            
            
            for idx in range(1, nums[pos] + 1): # 遍历广度
                if pos + idx < n and not visited[pos + idx]:
                    queue.append([pos + idx, step + 1])
                    # 注意这里
                    visited[pos + idx] = True
        return -1

ss = Solution()
res = ss.jump([1,2,1,1,1,4,4,1,5,2,3,4,1,4,2,5,2,6,4,4,2,2,5,6,2,3,4,5,4,4,2,3,1,4,1,6,2,3,5,3,6,6,1,2,5,3,3,4,6,1,1,5,3,3,4,5,1,4,2,6,6,4,1,4,1,2,1,4,4,2,1,2,2,5,6,5,4,4,3,6,5,2,5,6,1,4,3,4,3,3,1,2,6,5,3,6,1,2,6,4,2,3,3,4,6,3,5,3,2,3,3,1,3,2,4,1,3,5,1,1,5,2,4,2,2,5,3,4,2,1,3,3,1,2,4,5,4,6,2,5,6,4,6,5,2,2,1,4,6,4,2,4,1,6,3,3,6,1,4,5,4,5,1,2,3,6,1,4,3,2,5,1,5,2,5,1,2,3,3,6,6,3,5,2,6,1,6,4,3,4,1,2,5,1,5,6,5,3,1,5,6,3,6,3,5,6,2,2,6,3,4,1,4,1,1,3,4,1,5,6,5,4,2,5,3,6,4,1,2,3,5,6,5,2,3,6,1,3,4,6,3,2,5,5,1,6,6,6,2,3,5,5,4,5,2,1,6,6,2,5,1,3,2,5,1,2,3,4,1,1,5,1,4,1,2,2,6,1,4,3,2,1,6,5,1,6,2,3,5,3,6,6,5,2,1,4,4,5,3,5,5,1,3,2,6,1,6,6,4,6,5,3,3,1,6,2,6,4,2,4,1,2,2,2,2,1,5,4,3,6,3,2,5,5,4,6,4,1,5,2,4,6,2,4,5,5,3,4,6,6,1,6,6,5,3,1,4,6,5,3,5,3,5,2,3,4,6,2,5,6,6,2,5,6,1,1,5,4,5,6,6,5,5,3,3,4,4,5,2,6,5,1,3,2,3,1,3,1,2,3,5,2,5,3,2,2,3,4,4,2,6,5,1,3,4,6,1,6,4,4,2,4,5,2,5,6,6,1,3,1,1,4,6,5,6,4,1,3,1,1,6,2,6,4,5,5,3,5,3,6,6,2,1,3,2,5,5,3,5,3,3,5,3,2,1,2,2,6,1,6,4,2,2,2,6,2,4,2,5,5,2,3,1,1,5,6,6,3,4,6,2,1,2,1,4,2,5,6,5,5,3,2,1,5,1,3,2,2,5,1,6,1,6,5,6,2,6,3,6,5,1,4,6,3,3,6,6,4,1,4,6,3,4,1,4,2,5,5,5,4,2,5,6,6,3,1,5,4,2,3,6,1,6,4,1,5,5,6,4,5,4,4,6,5,2,5,1,4,3,2,6,1,5,2,6,2,6,1,2,3,5,5,4,4,5,4,2,1,4,1,4,6,1,1,2,6,2,3,6,4,4,5,6,6,4,1,6,3,2,4,1,4,5,5,2,6,6,4,2,5,4,6,6,5,2,4,1,1,4,1,1,4,6,1,5,2,4,6,5,1,6,6,6,2,1,6,1,5,5,4,5,2,3,2,2,2,6,4,6,2,4,6,4,5,1,3,2,4,2,6,6,4,3,3,1,1,4,4,5,5,4,1,6,5,1,3,3,6,5,5,3,6,3,5,2,4,3,4,6,5,2,6,6,1,2,3,4,6,1,5,6,4,6,6,1,1,2,4,6,4,1,1,6,6,2,1,1,2,3,6,5,3,1,6,1,3,6,2,4,5,3,2,5,3,5,5,2,1,3,4,4,6,2,4,3,3,1,5,3,3,1,2,5,2,5,2,2,4,2,2,4,6,3,1,4,2,3,4,2,2,6,3,2,6,3,3,5,5,5,2,3,1,6,5,4,5,2,6,5,2,1,2,2,2,2,2,3,2,6,3,1,5,6,1,4,6,5,3,3,5,5,6,5,1,4,3,5,5,3,4,6,4,6,3,2,1,1,6,2,2,5,5,3,1,3,5,6,3,6,2,5,6,2,1,4,4,2,2,6,2,1,5,6,1,1,3,3,5,5,3,2,5,2,1,3,2,4,3,5,2,5,5,4,1,1,3,4,3,1,3,5,5,4,5,5,1,3,5,4,6,5,4,2,1,2,6,6,4,4,5,6,6,6,3,4,3,5,2,5,6,5,2,1,4,5,3,1,6,4,1,5,4,5,2,5,1,4,2,6,3,3,5,1,3,4,3,3,6,6,5,5,5,4,5,3,6,6,6,4,2,4,4,1,2,2,2,3,2,2,5,6,5,6,3,3,1,1,4,1,6,6,5,3,2,6,5,2,1,6,1,4,6,4,1,2,1,2,5,1,1,6,3,2,5,4,5,2,6,5,6,2,2,1,5,5,1,6,2,1,3,4,5,4,3,1,5,6,5,4,1,2,3,4,2,2,6,2,4,3,2,5,3,2,2,5,6,3,3,2,1,4,5,2,3,2,5,3,1,3,6,3,6,4,2,5,3,6,1,6,5,2,1,5,2,1,1,4,3,3,1,1,2,2,1,1,4,1,6,5,5,6,4,6,6,2,2,2,6,1,1,1,1,5,2,2,1,6,5,6,1,3,1,6,4,1,2,1,5,1,1,3,6,4,5,4,2,3,4,1,5,2,2,1,6,2,3,2,3,3,1,1,4,5,5,3,5,3,6,4,5,4,4,4,2,2,1,4,6,0,0,0,0,0])
print(res)